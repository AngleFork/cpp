

[Go back to Richel Bilderbeek's C++ page](Cpp.htm).

 

 

 

 

 

([C++](Cpp.htm)) [FisherWrightSimulationExample2](CppFisherWrightSimulationExample2.htm)
========================================================================================

 

Technical facts
---------------

 

[Operating system(s) or programming environment(s)](CppOs.htm)

-   ![Lubuntu](PicLubuntu.png) [Lubuntu](CppLubuntu.htm) 15.04 (vivid)

[IDE(s)](CppIde.htm):

-   ![Qt Creator](PicQtCreator.png) [Qt Creator](CppQtCreator.htm) 3.1.1

[Project type](CppQtProjectType.htm):

-   ![console](PicConsole.png) [Console
    application](CppConsoleApplication.htm)

[C++ standard](CppStandard.htm):

-   ![C++98](PicCpp98.png) [C++98](Cpp98.htm)

[Compiler(s)](CppCompiler.htm):

-   [G++](CppGpp.htm) 4.9.2

[Libraries](CppLibrary.htm) used:

-   ![STL](PicStl.png) [STL](CppStl.htm): GNU ISO C++ Library, version
    4.9.2

 

 

 

 

 

[Qt project file](CppQtProjectFile.htm): ./CppFisherWrightSimulationExample2/CppFisherWrightSimulationExample2.pro
------------------------------------------------------------------------------------------------------------------

 

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ` include(../../ConsoleApplication.pri) include(../../Libraries/BoostAll.pri) include(../../Classes/CppNewickUtils/CppNewickUtils.pri) include(../../Classes/CppPedigree/CppPedigree.pri)  SOURCES += \     main.cpp \     parameters.cpp \     simulation.cpp \     individual.cpp \     helper.cpp \     sequence.cpp \     dna.cpp \     individual_test.cpp \     generation.cpp   HEADERS += \     parameters.h \     simulation.h \     individual.h \     helper.h \     sequence.h \     dna.h \     generation.h`
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 

 

 

 

 

./CppFisherWrightSimulationExample2/dna.h
-----------------------------------------

 

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ` #ifndef DNA_H #define DNA_H  #include <random> #include <string>  struct Dna {   explicit Dna(     const double mutation_rate,     std::mt19937& rnd_engine,     const std::string& sequence   );    //Creates random DNA   explicit Dna(     const double mutation_rate,     std::mt19937& rnd_engine,     const int dna_length   ) : Dna(mutation_rate,rnd_engine,CreateRandomDna(dna_length)) {}    Dna CreateOffspring() noexcept;    double GetMutationRate() const noexcept { return m_mutation_rate; }    std::mt19937& GetRndEngine() noexcept { return m_rnd_engine; }    const std::string& GetSequence() const noexcept { return m_sequence; }    private:    const double m_mutation_rate;   std::mt19937& m_rnd_engine;   const std::string m_sequence;    static char CreateRandomBasePair() noexcept;   static std::string CreateRandomDna(const int dna_length) noexcept;   double GetRandomFraction() noexcept;    #ifndef NDEBUG   static void Test() noexcept;   #endif };  ///Checks if different DNA have the same attributes (DNA and mutation rate) ///This does not take the random number generator into accoun bool operator==(const Dna& lhs, const Dna& rhs) noexcept;  #endif // DNA_H`
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 

 

 

 

 

./CppFisherWrightSimulationExample2/dna.cpp
-------------------------------------------

 

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ` #include "dna.h"  #include <algorithm> #include <cassert>  Dna::Dna(   const double mutation_rate,   std::mt19937& rnd_engine,   const std::string& sequence )   : m_mutation_rate{mutation_rate},     m_rnd_engine{rnd_engine},     m_sequence{sequence} {   #ifndef NDEBUG   Test();   #endif }  Dna Dna::CreateOffspring() noexcept {   //Go through all nucleotides,   //overwrite with a random base pair by chance   //(note: the might result in an A being overwritten by an A)   std::string next_sequence{m_sequence};   const int sz{static_cast<int>(next_sequence.size())};   for (int i=0; i!=sz; ++i)   {     const double p{GetRandomFraction()};     if (p < m_mutation_rate)     {       assert(i >= 0);       assert(i < static_cast<int>(next_sequence.size()));       next_sequence[i] = CreateRandomBasePair();     }   }   const Dna offspring(     m_mutation_rate,     m_rnd_engine,     next_sequence   );   return offspring; }  char Dna::CreateRandomBasePair() noexcept {   switch (std::rand() % 4)   {     case 0: return 'A';     case 1: return 'C';     case 2: return 'G';     case 3: return 'T';   }   assert(!"Should not get here"); }  std::string Dna::CreateRandomDna(   const int dna_length ) noexcept {   assert(dna_length >= 0);   std::string s(dna_length,0);   std::generate(std::begin(s),std::end(s),CreateRandomBasePair);   return s; }  double Dna::GetRandomFraction() noexcept {   static std::uniform_real_distribution<double> d(0.0,1.0);   //The random value x gets drawn here   const double f{d(m_rnd_engine)};    assert(f >= 0.0);   assert(f <= 1.0);   return f; }   #ifndef NDEBUG void Dna::Test() noexcept {   {     static bool is_tested = false;     if (is_tested) return;     is_tested = true;   }   //Create random DNA   std::mt19937 rnd_engine;   {     const int dna_length{3};     const std::string dna{Dna::CreateRandomDna(dna_length)};     assert(dna_length == static_cast<int>(dna.size()));   } } #endif  bool operator==(const Dna& lhs, const Dna& rhs) noexcept {   return        lhs.GetSequence() == rhs.GetSequence() //Sequence first, because that is expected to vary more     && lhs.GetMutationRate() == rhs.GetMutationRate()   ; }`
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 

 

 

 

 

./CppFisherWrightSimulationExample2/generation.h
------------------------------------------------

 

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ` #ifndef GENERATION_H #define GENERATION_H  #include <vector>  #include "individual.h" #include "sequence.h"  //Just a collection of Individuals struct Generation {   Generation(const std::vector<Individual>& individuals)     : m_individuals{individuals} {}   bool empty() const noexcept { return m_individuals.empty(); }    std::vector<Individual>& GetIndividuals() noexcept { return m_individuals; }   const std::vector<Individual>& GetIndividuals() const noexcept { return m_individuals; }   std::vector<Sequence> GetSequences() const noexcept;    std::vector<Individual>::size_type size() const noexcept { return m_individuals.size(); }   const Individual& operator[](const int index) const noexcept;   Individual& operator[](const int index) noexcept;    std::vector<Individual> m_individuals; };  #endif // GENERATION_H`
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 

 

 

 

 

./CppFisherWrightSimulationExample2/generation.cpp
--------------------------------------------------

 

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ` #include "generation.h"  #include <algorithm> #include <cassert>   std::vector<Sequence> Generation::GetSequences() const noexcept {   std::vector<Sequence> alignments;   std::transform(     std::begin(m_individuals),     std::end(m_individuals),     std::back_inserter(alignments),     [](const Individual& i)     {       const std::string description = std::to_string(i.GetIndex());       assert(std::stoi(description) == i.GetIndex());       return Sequence(description,i.GetDna().GetSequence());     }   );    return alignments; }  const Individual& Generation::operator[](const int index) const noexcept {   assert(index >= 0);   assert(index < static_cast<int>(m_individuals.size()));   return m_individuals[index]; }  Individual& Generation::operator[](const int index) noexcept {   assert(index >= 0);   assert(index < static_cast<int>(m_individuals.size()));   return m_individuals[index]; }`
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 

 

 

 

 

./CppFisherWrightSimulationExample2/helper.h
--------------------------------------------

 

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ` #ifndef HELPER_H #define HELPER_H  #include <map> #include <string> #include <vector>  struct Helper {   Helper() noexcept;   std::string ContainerToStr(const std::vector<std::string>& s, const std::string& seperator = " ") const noexcept;   std::map<std::string,int> CreateSortedTally(const std::vector<std::string>& v) const noexcept;   std::vector<std::pair<std::string,int>> CreateTally(const std::vector<std::string>& v) const noexcept;   std::vector<std::string> FileToVector(const std::string& filename) const noexcept;   std::string GetFileBasename(const std::string& filename) const noexcept { return GetFileBasenameBoostXpressive(filename); }   bool IsRegularFileStl(const std::string& filename) const noexcept;    private:   ///Most concise   std::string GetFileBasenameBoostFilesystem(const std::string& filename) const noexcept;   ///Can deal with Windows filenames as well   std::string GetFileBasenameBoostXpressive(const std::string& filename) const noexcept;    #ifndef NDEBUG   static void Test() noexcept;   #endif };  #endif // HELPER_H`
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 

 

 

 

 

./CppFisherWrightSimulationExample2/helper.cpp
----------------------------------------------

 

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ` #include "helper.h"  #include <algorithm> #include <cassert> #include <fstream> #include <iterator> #include <sstream>  #include <boost/filesystem.hpp> #include <boost/xpressive/xpressive.hpp>  template <class Container> std::string ContainerToStrImpl(const Container& c, const std::string& seperator) {   std::stringstream s;   std::copy(c.begin(),c.end(),     std::ostream_iterator<typename Container::value_type>(s,seperator.c_str()));   return s.str(); }  Helper::Helper() noexcept {   #ifndef NDEBUG   Test();   #endif }  std::string Helper::ContainerToStr(   const std::vector<std::string>& s,   const std::string& seperator ) const noexcept {   return ContainerToStrImpl(s,seperator); }   std::map<std::string,int> Helper::CreateSortedTally(   const std::vector<std::string>& v ) const noexcept {   std::map<std::string,int> m;   for (const std::string& s: v)   {     if (m.find(s) == m.end())     {       m[s] = 1;     }     else     {       ++m[s];     }   }   return m; }  std::vector<std::pair<std::string,int>> Helper::CreateTally(   const std::vector<std::string>& v ) const noexcept {   std::vector<std::pair<std::string,int>> w;   for (const std::string& s: v)   {     const auto iter = std::find_if(std::begin(w),std::end(w),       [s](const auto& p) { return p.first == s; }     );      if (iter == std::end(w))     {       w.push_back(std::make_pair(s,1));     }     else     {       ++((*iter).second);     }   }   return w; }  ///FileToVector reads a file and converts it to a std::vector<std::string> ///From http://www.richelbilderbeek.nl/CppFileToVector.htm std::vector<std::string> Helper::FileToVector(   const std::string& filename ) const noexcept {   assert(IsRegularFileStl(filename));   std::vector<std::string> v;   std::ifstream in(filename.c_str());   std::string s;   for (int i=0; !in.eof(); ++i)   {     std::getline(in,s);     v.push_back(s);   }   return v; }   std::string Helper::GetFileBasenameBoostFilesystem(const std::string& filename) const noexcept {   return boost::filesystem::basename(filename); }  std::string Helper::GetFileBasenameBoostXpressive(const std::string& filename) const noexcept {   const boost::xpressive::sregex rex     = boost::xpressive::sregex::compile(       "((.*)(/|\\\\))?([0-9A-Za-z_]*)((\\.)([A-Za-z]*))?" );   boost::xpressive::smatch what;    if( boost::xpressive::regex_match( filename, what, rex ) )   {     return what[4];   }    return ""; }   ///Determines if a filename is a regular file ///From http://www.richelbilderbeek.nl/CppIsRegularFile.htm bool Helper::IsRegularFileStl(   const std::string& filename ) const noexcept {   std::fstream f;   f.open(filename.c_str(),std::ios::in);   return f.is_open(); }   #ifndef NDEBUG void Helper::Test() noexcept {   {     static bool is_tested {false};     if (is_tested) return;     is_tested = true;   }   //CreateTally   {     const std::vector<std::string> v = { "A"};     const std::vector<std::pair<std::string,int>> m{Helper().CreateTally(v)};     assert(m.size() == 1);     assert(m[0].first == "A");     assert(m[0].second == 1);   }   {     const std::vector<std::string> v = { "A", "A" };     const std::vector<std::pair<std::string,int>> m{Helper().CreateTally(v)};     assert(m.size() == 1);     assert(m[0].first == "A");     assert(m[0].second == 2);   }   {     const std::vector<std::string> v = { "A", "B" };     const std::vector<std::pair<std::string,int>> m{Helper().CreateTally(v)};     assert(m.size() == 2);     assert(m[0].first == "A");     assert(m[0].second == 1);     assert(m[1].first == "B");     assert(m[1].second == 1);   }   {     const std::vector<std::string> v = { "B", "A", "B" };     const std::vector<std::pair<std::string,int>> m{Helper().CreateTally(v)};     assert(m.size() == 2);     assert(m[0].first == "B");     assert(m[0].second == 2);     assert(m[1].first == "A");     assert(m[1].second == 1);   }   {     assert(Helper().GetFileBasenameBoostFilesystem("") == std::string(""));     assert(Helper().GetFileBasenameBoostFilesystem("tmp.txt") == std::string("tmp"));     assert(Helper().GetFileBasenameBoostFilesystem("test_output.fas") == std::string("test_output"));     assert(Helper().GetFileBasenameBoostFilesystem("test_output_0.fas") == std::string("test_output_0"));     assert(Helper().GetFileBasenameBoostFilesystem("tmp") == std::string("tmp"));     assert(Helper().GetFileBasenameBoostFilesystem("MyFolder/tmp") == std::string("tmp"));     assert(Helper().GetFileBasenameBoostFilesystem("MyFolder/tmp.txt") == std::string("tmp"));     //assert(Helper().GetFileBasenameBoostFilesystem("MyFolder\\tmp.txt") == std::string("tmp"));     assert(Helper().GetFileBasenameBoostFilesystem("MyFolder/MyFolder/tmp") == std::string("tmp"));     assert(Helper().GetFileBasenameBoostFilesystem("MyFolder/MyFolder/tmp.txt") == std::string("tmp"));     //assert(Helper().GetFileBasenameBoostFilesystem("MyFolder/MyFolder\\tmp.txt") == std::string("tmp"));      assert(Helper().GetFileBasenameBoostXpressive("") == std::string(""));     assert(Helper().GetFileBasenameBoostXpressive("tmp.txt") == std::string("tmp"));     assert(Helper().GetFileBasenameBoostXpressive("test_output.fas") == std::string("test_output"));     assert(Helper().GetFileBasenameBoostXpressive("test_output_0.fas") == std::string("test_output_0"));     assert(Helper().GetFileBasenameBoostXpressive("tmp") == std::string("tmp"));     assert(Helper().GetFileBasenameBoostXpressive("MyFolder/tmp") == std::string("tmp"));     assert(Helper().GetFileBasenameBoostXpressive("MyFolder/tmp.txt") == std::string("tmp"));     assert(Helper().GetFileBasenameBoostXpressive("MyFolder\\tmp.txt") == std::string("tmp"));     assert(Helper().GetFileBasenameBoostXpressive("MyFolder/MyFolder/tmp") == std::string("tmp"));     assert(Helper().GetFileBasenameBoostXpressive("MyFolder/MyFolder/tmp.txt") == std::string("tmp"));     assert(Helper().GetFileBasenameBoostXpressive("MyFolder/MyFolder\\tmp.txt") == std::string("tmp"));   }   //ShowPhylogeny   {    } } #endif`
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 

 

 

 

 

./CppFisherWrightSimulationExample2/individual.h
------------------------------------------------

 

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ` #ifndef INDIVIDUAL_H #define INDIVIDUAL_H  #include <string> #include <random>  #include "dna.h" #include "pedigree.h"  struct Individual {   //Pedigree can only be created by parent using CreateOffspring   //CreateOffspring creates a std::shared_ptr   //Must use std::shared_ptr, due to use of std::weak_ptr   Individual(     const Dna& dna,     const std::shared_ptr<Pedigree>& pedigree   );    Individual CreateOffspring(const std::string& name = "") noexcept;    const Dna& GetDna() const noexcept { return m_dna; }   int GetIndex() const noexcept { return m_index; }   std::shared_ptr<const Pedigree> GetPedigree() const noexcept { return m_pedigree; }   std::shared_ptr<Pedigree> GetPedigree() noexcept { return m_pedigree; }   void SetName(const std::string& name) noexcept;    private:   Dna m_dna; //Non-const, because RNG is passed on    /// Unique index as long as there are less than (2^32)/2 Individuals   const int m_index;    const std::shared_ptr<Pedigree> m_pedigree;    /// Counter that increases when an Individual is constructed   static int sm_index;    #ifndef NDEBUG   static void Test() noexcept;   #endif };   ///Checks if different individuals have the same attributes (e.g. DNA) ///This does not take the index of the Individuals into account, as ///these are all (semi)unique bool operator==(const Individual& lhs, const Individual& rhs) noexcept;  #endif // INDIVIDUAL_H`
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 

 

 

 

 

./CppFisherWrightSimulationExample2/individual.cpp
--------------------------------------------------

 

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ` #include "individual.h"  #include <cassert>  #include "dna.h" #include "parameters.h"  int Individual::sm_index = 0;  Individual::Individual(   const Dna& dna,   const std::shared_ptr<Pedigree>& pedigree   )   : m_dna{dna},     m_index{sm_index++}, //Use the previous value     m_pedigree{pedigree} {   #ifndef NDEBUG   Test();   #endif   assert(m_pedigree); }  Individual Individual::CreateOffspring(const std::string& name) noexcept {   Individual kid(     m_dna.CreateOffspring(),     m_pedigree->CreateOffspring(name)   );   if (name.empty())   {     int index = kid.GetIndex();     std::string name;     while (index != 0)     {       name += std::string(1,'A' + (index % 26));       index /= 26;     }     kid.SetName(name);   }    return kid; }  void Individual::SetName(const std::string& name) noexcept {   m_pedigree->SetName(name); }  bool operator==(const Individual& lhs, const Individual& rhs) noexcept {   return lhs.GetDna() == rhs.GetDna(); }`
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 

 

 

 

 

./CppFisherWrightSimulationExample2/individual\_test.cpp
--------------------------------------------------------

 

  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ` #include "individual.h"  #include <cassert> #include <iostream>  #include "parameters.h"  #ifndef NDEBUG void Individual::Test() noexcept {   {     static bool is_tested {false};     if (is_tested) return;     is_tested = true;   }   std::mt19937 rnd_engine;   const int dna_length{10000};   const int n_generations{100};   const double mutation_rate{0.0};   const Parameters p(dna_length,mutation_rate,n_generations,1,42);   //Pedigree can be formed, 1 kid   {     const std::shared_ptr<Pedigree> parent_pedigree{Pedigree::Create("X")};     Individual parent(       Dna(mutation_rate,rnd_engine,dna_length),parent_pedigree     );     const Individual kid{parent.CreateOffspring("A")};      assert(kid.GetPedigree()->GetParent().lock());     assert(kid.GetPedigree()->GetParent().lock() == parent_pedigree);     assert(parent_pedigree->ToNewick() == kid.GetPedigree()->GetParent().lock()->ToNewick());   }   {     /*       +-A      |    --X      |      +-B      */     const auto root_pedigree = Pedigree::Create("X");     Individual root(       Dna(mutation_rate,rnd_engine,dna_length),root_pedigree     );     const Individual a{root.CreateOffspring("A")};     const Individual b{root.CreateOffspring("B")};     const std::string expected{"(A:1,B:1);"};     const std::string found{root.GetPedigree()->ToNewick()};     if (found != expected) { std::cerr << found << '\n'; }     assert(found == expected);   }   //Three branches of short length   {     /*         +-C        |      +-A      | |    --X +-D      |      +-B-E      */     const auto root_pedigree = Pedigree::Create("X");     Individual root(       Dna(mutation_rate,rnd_engine,dna_length),root_pedigree     );     auto a = root.CreateOffspring("A");     auto b = root.CreateOffspring("B");     const auto c = a.CreateOffspring("C");     const auto d = a.CreateOffspring("D");     const auto e = b.CreateOffspring("E");     const std::string expected{"((C:1,D:1):1,E:2);"};     const std::string found{root.GetPedigree()->ToNewick()};     if (found != expected) { std::cerr << found << '\n'; }     assert(found == expected);   } } #endif`
  -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 

 

 

 

 

./CppFisherWrightSimulationExample2/main.cpp
--------------------------------------------

 

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ` #include <cassert> #include <fstream> #include <iostream>  #include <QFile>  #include "helper.h" #include "parameters.h" #include "simulation.h"  #include "newickutils.h"  int main() {   //1) Read parameters from file   const int dna_length{10};   const double mutation_rate{0.01};   const int n_generations{10};   const int pop_size{100000};   const int seed{42};   const Parameters parameters(     dna_length,     mutation_rate,     n_generations,     pop_size,     seed   );    //2) Run simulation   Simulation simulation(parameters);   //Loop n_generations   //const int n_generations{parameters.GetNumberOfGenerations()};   for (int i=0; i!=n_generations; ++i)   {     simulation.NextGeneration();     if (!simulation.GetCurrentSequences().empty())     {       //Only show the sequence of the first individual       //std::cout << i << ": " << simulation.GetCurrentSequences()[0].GetSequence() << '\n';     }   }   const std::string pedigree{simulation.GetPedigree()};    //Display as newick   std::cout << pedigree << std::endl;    //Display as phylogeny   NewickUtils().Display(pedigree); }`
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 

 

 

 

 

./CppFisherWrightSimulationExample2/parameters.h
------------------------------------------------

 

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ` #ifndef PARAMETERS_H #define PARAMETERS_H  #include <string>  struct Parameters {   ///Factory member function   static Parameters CreateParameters(const std::string& filename);    ///Create parameters from scratch   explicit Parameters(     const int dna_length,     const double mutation_rate,     const int n_generations,     const int pop_size,     const int seed   );    int GetDnaLength() const noexcept { return m_dna_length; }   double GetMutationRate() const noexcept { return m_mutation_rate; }   int GetNumberOfGenerations() const noexcept { return m_n_generations; }   int GetPopSize() const noexcept { return m_pop_size; }   int GetSeed() const noexcept { return m_seed; }    private:   const int m_dna_length;   const double m_mutation_rate;   const int m_n_generations;   const int m_pop_size;   const int m_seed;    #ifndef NDEBUG   static void Test() noexcept;   #endif };  std::ostream& operator<<(std::ostream& os, const Parameters& parameters);   #endif // PARAMETERS_H`
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 

 

 

 

 

./CppFisherWrightSimulationExample2/parameters.cpp
--------------------------------------------------

 

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ` #include "parameters.h"  #include <cassert> #include <fstream> #include <stdexcept> #include <sstream>     Parameters::Parameters(   const int dna_length,   const double mutation_rate,   const int n_generations,   const int pop_size,   const int seed )   :     m_dna_length{dna_length},     m_mutation_rate{mutation_rate},     m_n_generations{n_generations},     m_pop_size{pop_size},     m_seed{seed} {   #ifndef NDEBUG   Test();   #endif    if (m_dna_length < 0)   {     std::stringstream s;     s << "Parameters::Parameters: DNA length must be positive, DNA length given: "       << m_dna_length     ;     throw std::logic_error(s.str().c_str());   }   if (m_n_generations < 0)   {     std::stringstream s;     s << "Parameters::Parameters: "       << "number of generations must be positive, "       << "number of generations supplied: "       << m_n_generations     ;     throw std::logic_error(s.str().c_str());   }   if (m_pop_size < 0)   {     std::stringstream s;     s << "Parameters::Parameters: "       << "population size must be positive, "       << "population size supplied: "       << m_pop_size     ;     throw std::logic_error(s.str().c_str());   }   if (m_seed < 0)   {     std::stringstream s;     s << "Parameters::Parameters: cannot create Parameters with seed < 0";     throw std::logic_error(s.str().c_str());   }  }  Parameters Parameters::CreateParameters(const std::string& filename) {   std::string dna_length_str{""};   int dna_length{0};   std::string mutation_rate_str{""};   double mutation_rate{0.0};   std::string n_generations_str{""};   int n_generations{0};   std::string pop_size_str{""};   int pop_size{0};   std::string seed_str{""};   int seed{0};    std::ifstream f(filename.c_str());   //TODO: Add safety is file has wrong format   f     >> dna_length_str >> dna_length     >> mutation_rate_str >> mutation_rate     >> n_generations_str >> n_generations     >> pop_size_str >> pop_size     >> seed_str >> seed   ;   const Parameters parameters(     dna_length,     mutation_rate,     n_generations,     pop_size,     seed   );   return parameters; }    #ifndef NDEBUG void Parameters::Test() noexcept {   {     static bool is_tested {false};     if (is_tested) return;     is_tested = true;   }   //Test recovery of parameters   {     const int dna_length{3495};     const double mutation_rate{0.34758};     const int n_generations{63223};     const int pop_size{2376};     const int seed{234};     Parameters p(       dna_length,       mutation_rate,       n_generations,       pop_size,       seed     );     assert(p.GetDnaLength() == dna_length);     assert(p.GetMutationRate() == mutation_rate);     assert(p.GetNumberOfGenerations() == n_generations);     assert(p.GetPopSize() == pop_size);     assert(p.GetSeed() == seed);   }   {     const int dna_length{345};     const double mutation_rate{0.34758};     const int n_generations{63223};     const int pop_size{2376};     const int seed{43};     Parameters original(       dna_length,       mutation_rate,       n_generations,       pop_size,       seed     );     const std::string filename{"tmp.txt"};     { std::ofstream f(filename.c_str()); f << original; }     const Parameters p(Parameters::CreateParameters(filename));     assert(p.GetDnaLength() == dna_length);     assert(p.GetMutationRate() == mutation_rate);     assert(p.GetNumberOfGenerations() == n_generations);     assert(p.GetPopSize() == pop_size);     assert(p.GetSeed() == seed);   } } #endif  std::ostream& operator<<(std::ostream& os, const Parameters& parameters) {   os     << "dna_length " << parameters.GetDnaLength() << '\n'     << "mutation_rate " << parameters.GetMutationRate() << '\n'     << "n_generations " << parameters.GetNumberOfGenerations() << '\n'     << "pop_size " << parameters.GetPopSize() << '\n'     << "seed " << parameters.GetSeed() << '\n'   ;   return os; }`
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 

 

 

 

 

./CppFisherWrightSimulationExample2/sequence.h
----------------------------------------------

 

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ` #ifndef SEQUENCE_H #define SEQUENCE_H  #include <string>  struct Sequence {   explicit Sequence(const std::string& description, const std::string& sequence);    const std::string& GetDescription() const noexcept { return m_description; }   const std::string& GetSequence() const noexcept { return m_sequence; }    private:   const std::string m_description;   const std::string m_sequence;    #ifndef NDEBUG   static void Test() noexcept;   #endif };  bool operator==(const Sequence& lhs, const Sequence& rhs) noexcept;  #endif // SEQUENCE_H`
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 

 

 

 

 

./CppFisherWrightSimulationExample2/sequence.cpp
------------------------------------------------

 

  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ` #include "sequence.h"  #include <algorithm> #include <cassert> #include <sstream> #include <stdexcept>  Sequence::Sequence(const std::string& description, const std::string& sequence)   : m_description{description},     m_sequence{sequence} {   #ifndef NDEBUG   Test();   #endif   const auto iter = std::find_if_not(     std::begin(m_sequence),     std::end(m_sequence),     [](const char c) { return c == 'A' || c == 'C' ||  c == 'G' ||  c == 'T'; }   );   if (iter != std::end(m_sequence))   {     std::stringstream s;     s << "Sequence::Sequence: sequence can only contain the characters 'A','C','G','T'";     throw std::logic_error(s.str().c_str());   } }  #ifndef NDEBUG void Sequence::Test() noexcept {   {     static bool is_tested {false};     if (is_tested) return;     is_tested = true;   }   {     const std::string description{"description"};     const std::string sequence{"ACGT"};     const Sequence s(description,sequence);     assert(s.GetDescription() == description);     assert(s.GetSequence() == sequence);   }   {     try     {       Sequence s("description","incorrect_sequence");       assert(!"Should not get here");     }     catch (std::logic_error&)     {       //Well detected!     }   } } #endif  bool operator==(const Sequence& lhs, const Sequence& rhs) noexcept {   return     lhs.GetDescription() == rhs.GetDescription()     && lhs.GetSequence() == rhs.GetSequence()   ; }`
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 

 

 

 

 

./CppFisherWrightSimulationExample2/simulation.h
------------------------------------------------

 

  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ` #ifndef SIMULATION_H #define SIMULATION_H  #include <random> #include <vector>  #include "generation.h" #include "individual.h" #include "parameters.h" #include "sequence.h"  ///Fisher-Wright simulation ///with individuals that only have DNA struct Simulation {   ///Use randomly created individuals   Simulation(const Parameters& parameters) : Simulation(parameters,CreateFirstGeneration(parameters)) {}    std::string GetPedigree() noexcept;    const std::vector<Generation>& GetGenerations() const noexcept { return m_generations; }    ///Obtain the sequences of the current (most recent) simulation   ///Equivalent to simulation.GetGenerations().back().GetSequences()   std::vector<Sequence> GetCurrentSequences() const noexcept;    //Go to the next generation   void NextGeneration() noexcept;    private:   std::vector<Generation> m_generations;    const Parameters m_parameters;    ///Random number generator engine   std::mt19937 m_rnd_engine;    ///Put in your own individuals   Simulation(     const Parameters& parameters,     const Generation& generation   );    ///Create initial population of individuals with random DNA sequences   Generation CreateFirstGeneration(     const Parameters& parameters   ) noexcept;    ///Create initial population of individuals with random DNA sequences   ///Non-const, because random numbers are used   Generation CreateNextGeneration(     Generation& current_generation   ) noexcept;    static std::vector<Parameters> CreateTestParameters() noexcept;    #ifndef NDEBUG   static void Test() noexcept;   #endif };  #endif // SIMULATION_H`
  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 

 

 

 

 

./CppFisherWrightSimulationExample2/simulation.cpp
--------------------------------------------------

 

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ` #include "simulation.h"  #include <algorithm> #include <cassert> #include <fstream> #include <iterator> #include <sstream>  #include <boost/numeric/conversion/cast.hpp>  #include "dna.h" #include "individual.h"  Simulation::Simulation(   const Parameters& parameters,   const Generation& generation )   : m_generations{},     m_parameters{parameters},     m_rnd_engine{static_cast<unsigned int>(parameters.GetSeed())} {   #ifndef NDEBUG   Test();   #endif    m_generations.push_back(generation); }  Generation Simulation::CreateFirstGeneration(   const Parameters& parameters ) noexcept {   //Create parameters.GetPopSize() individuals   // with DNA length of parameters.GetDnaLength()   std::vector<Individual> v;   const int dna_length{parameters.GetDnaLength()};   const double mutation_rate{parameters.GetMutationRate()};   std::generate_n(     std::back_inserter(v),     parameters.GetPopSize(),     [dna_length,mutation_rate,this]()     {       return Individual(         Dna(mutation_rate,m_rnd_engine,dna_length),           Pedigree::Create()         );     }   );   Generation g(v);   return g; }   Generation Simulation::CreateNextGeneration(   Generation& current_generation   ) noexcept {   std::vector<Individual> individuals;    const int n{m_parameters.GetPopSize()};   for (int i=0; i!=n; ++i)   {     const int index = std::rand() % n;     assert(index >= 0);     assert(index < static_cast<int>(current_generation.size()));     Individual& parent{current_generation[index]};     const Individual kid{parent.CreateOffspring()};     individuals.push_back(kid);   }   const Generation next_generation(individuals);   return next_generation; }   std::vector<Parameters> Simulation::CreateTestParameters() noexcept {   std::vector<Parameters> v;   //0: shortest interesting simulation   v.push_back(     Parameters(       1,   //dna_length       0.0, //mutation_rate       1,   //n_generations       1,   //pop_size       42   //seed     )   );   //Bash at simulation by adding zero-length parameters   for (int i=0; i!=8; ++i)   {     v.push_back(       Parameters(         i & 1, //dna_length         0.0,   //mutation_rate         i & 2, //n_generations         i & 4, //pop_size         42     //seed       )     );   }   return v; }  std::vector<Sequence> Simulation::GetCurrentSequences() const noexcept {   return GetGenerations().back().GetSequences(); }  std::string Simulation::GetPedigree() noexcept {   //Take the first individual from the first generation   if (this->m_generations.empty()) return "";   if (this->m_generations.back().empty()) return "";    std::shared_ptr<const Pedigree> pedigree = m_generations.back().GetIndividuals()[0].GetPedigree();   while (1)   {     std::shared_ptr<const Pedigree> parent = pedigree->GetParent().lock();     if (!parent) break;     pedigree = parent;   }   return pedigree->ToNewick(); }  void Simulation::NextGeneration() noexcept {   m_generations.push_back(     CreateNextGeneration(m_generations.back())   ); }  #ifndef NDEBUG void Simulation::Test() noexcept {   {     static bool is_tested = false;     if (is_tested) return;     is_tested = true;   }   std::mt19937 rnd_engine;   for (const auto parameters: CreateTestParameters())   {     //Run simulation     Simulation simulation(parameters);     const int n_generations{parameters.GetNumberOfGenerations()};     for (int i=0; i!=n_generations; ++i)     {       simulation.NextGeneration();     }      //Sample the alignments     const std::vector<Sequence> alignments{       simulation.GetCurrentSequences()     };     assert(parameters.GetPopSize() == static_cast<int>(alignments.size()));   }   //If mutation rate is zero, a population of one individuals remains the same   {     const int dna_length{10000};     const int n_generations{100};     const double mutation_rate{0.0};     const Parameters p(dna_length,mutation_rate,n_generations,1,42);     const Individual i(       Dna(mutation_rate,rnd_engine,dna_length),Pedigree::Create());     std::vector<Individual> is;     is.push_back(i);     Simulation s(p,is);     for (int i=0; i!=n_generations; ++i) { s.NextGeneration(); }     assert(s.GetGenerations().back().m_individuals == is);   } } #endif`
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 

 

 

 

 

[Go back to Richel Bilderbeek's C++ page](Cpp.htm).



 

[![Valid XHTML 1.0 Strict](valid-xhtml10.png){width="88"
height="31"}](http://validator.w3.org/check?uri=referer)

This page has been created by the [tool](Tools.htm)
[CodeToHtml](ToolCodeToHtml.htm)
